二、面向对象
37.局部变量和成员变量的区别：
	局部变量是属于局部作用域的变量，局部作用域：方法体、代码块属于局部作用域
	成员变量定义于类中方法外：
		1. 成员变量属于实例的，可以通过 实例. 的方式进行访问
		2. 静态成员变量是属于类的，实例也可以访问，也可以使用 类名. 的方式进行访问
	
38.变量的使用顺序？
	局部变量 => 本类成员变量 => 父类成员变量 => 父类... => 报错

39.类和对象的关系？
	类是对象的主观概念，对象是类的客观存在
	
	类像是对象的图纸，对象通过图纸进行创建
	
40.java描述事物最基本的单位？
	一类事物

41.什么叫面向对象？
	我们在日常生活中，解决某些问题的时候，总会或多或少的去使用到工具、或由其他人完成
		我们解决问题的方式往往是先细化问题，解决小的部分，小的部分或使用工具，或求助于他人
		在我们解决问题的过程中，所使用的工具、求助的人，都看做目标，目标可以称为对象
		我们通过 “使用” “对象” 这样解决问题的方式，就可以称之为 “面向对象解决问题” 简称面向对象
		
	我们的程序开发，往往都是源于生活的，当有人提出了问题后，我们就需要编程来解决问题
		在我们通过开发解决问题的过程中，我们也可以借用生活中的 “面向对象” 概念，来细化问题，并善于使用工具
		这样细化问题，通过高效的使用工具完成开发的过程，就可以称之问 “面向对象开发”
		而这些 “工具” 也就是我们日常开发中所使用的 类 和 对象

42.什么是封装？封装的原则？好处？
	封装是指我们将一些独立的功能代码块进行集中处理（放到类 或 方法中），我们可以通过简单的方式（构建实例及调用方法）使用这些代码，并且处理过的代码能够重复使用
		我们在使用这些处理过的代码的时候，只需要知道怎么使用，而不用关注内部如何实现的
	
	封装的原则：高内聚，低耦合
	好处：提高代码的复用性、维护性
	

43.封装就是私有，对吗？为什么？
	私有只是实现代码独立及封闭（不被外部干扰）的一种方式，不能说简言封装就是私有
	

44.Java中参数传递的问题：
	按值传递：
		如果参数是基本数据类型，则传递的是一个拷贝副本
		如果参数是引用数据类型，则传递的是引用地址的拷贝

45.构造方法，set方法都可以给成员变量赋值，这两种赋值方式有什么区别？
	构造方法是在构造实例的时候就调用的，通过构造方法的方式可以做成员变量的初始化
	set 方法是在代码逻辑运行时，可以对实例变量赋值，可以根据逻辑处理不同的赋值

46.static关键字的特点？注意事项是什么？有什么好处和弊端？
	使用 static 修饰的成员（变量、方法）被称为静态变量
	特点：
		被 static 修饰的成员会随着类的加载而加载
		本质上来说被 static 修饰的成员是属于类的，所以会被类的所有实例共享
		
	注意事项：
		由于被 static 修饰的成员是会随着类的加载而加载，
			1. 在静态成员方法内，无法访问 非静态成员
			2. 实例方法可以使用静态成员（实例构建时，静态成员已经存在了）
			3. 在静态方法中没有 this 关键字（实例未初始化）
	
	好处：数据共享
	弊端：数据共享？访问实例受限？

47.类变量和实例变量的区别？
	类变量：使用 static 修饰，属于类，被所有实例共享，无法被 this 访问到
	实例变量：属于实例，在每次构建实例的时候，都会是新的数据，可以被 this 访问到

48.构造方法能不能重载？
	构造方法可以重载
		在构建实例的时候，如果我们没有为类提供构造方法，系统会默认提供一个无参构造
		如果我们手动添加了构造方法，系统将不再会提供默认的无参构造，在提供构造方法的时候，最好同时提供 有参构造，无参构造

49.静态代码块和构造代码块的区别？
	静态代码块和构造代码块都定义与 类中方法 外
	
	静态代码块使用 static 修饰符修饰，会随着类的加载而执行
	构造代码块不用修饰，体现为一对大括号，在每次构造实例时都会在 构造方法之前执行
	

50.什么是继承？
	继承是指类与类的关系，继承关系
	从上到下来说:
		当我们在定义一个类的时候，在这个类中要使用某个已存在的类中的功能（方法或变量），我们无需重新在这个新的类中书写这些功能
			只需要使新的类继承已有的类，新类就能够拿到已有类中的功能
			继承使用 extends 关键字
	
	从下到上来说：
		当我们定义的某些类，类中存在于重复的功能代码，那么我们就可以将这些重复的功能代码抽取出来，向上抽取放到一个新的类中
			然后使已有类继承存放抽取代码的类

51.继承的的特点和好处，弊端？
	特点：	
		只能单继承，可以多层继承
	
	好处：
		提高代码的复用性、维护性、可扩展性
		
	弊端：
		继承是侵入式的，局限了子类
		降低了代码的灵活性
		增强了代码的耦合性

52.this和super的区别？
	this 用来指代当前实例（存储子类实例引用），在继承关系中，可以使用 this 访问子类的成员
	super 指代父类，可以用 super 访问父类中的成员，也可以通过 super 调用 父类的构造方法，进行数据的初始化

53．super（）和this（）在构造方法能同时使用吗？super关键字和this关键字能否在构造函数中共存？
	不能同时使用
		this 是调用当前子类的构造方法，需要在代码的第一行有效执行代码
		super 是调用父类的构造方法，也需要在代码的第一行有效执行代码 
			二者有冲突
			
	关键字的使用可以共存

54.为什么每个构造函数中第一行都有默认的super()?
	因为在构造子类实例的时候，有可能会用到父类中的成员，
		所以需要先完成对父类中的成员的初始化
	
55.为什么默认的super()都是空参的呢？
	因为 Object 基类中只有 空参构造
	因为在构造实例的时候，系统都会默认提供一个 无参构造
		默认的 super 是空参也是因为 系统默认提供了空的父类构造方法

56.构造方法的特点？
	在每次构造实例的时候，都会先执行构造方法
		可以在构造方法中进行数据初始化
	
57.this的作用？
	this 是对实例的引用，保存的是实例的内存地址
		通过 this 可以访问当前实例的实例属性、实例方法

58.子父类都有静态代码块，构造代码块，构造方法的执行顺序？
	1. 父静态代码块执行 （创建子类型的的时候，发现子存在父类，加载父类字节码，父类静态代码块执行）
	2. 子静态代码块执行 （创建子类型，加载子类字节码）
	3. 父构造代码块执行
	4. 父构造方法执行
	5. 子构造代码块执行
	6. 子构造方法执行
	
	
	
59.final修饰的变量的初始化时机
	1. 在声明的时候进行赋值
	2. 构造方法中进行赋值

60.final如果修饰局部变量，会发生什么事情？
	局部变量变成常量

61.什么是多态？多态的体现，前提，好处和弊端分别是什么？
	多态:
		指同一个对象（父类型变量），在不同时刻（赋值子类实例）所表现出的不同形态（不同的子实例）
		
	体现：
		父类型引用子类实例
		存在方法重写
		
	前提:
		存在继承或实现关系
	
	好处：提高程序的扩展性、灵活性
	弊端：无法使用子类的特有的功能
	

62.多态中成员方法和变量的特点？
	多态中的成员变量：
		编译看左：java 的代码分为编译和运行两种状态，在编译阶段，多态代码还只是一个父类型变量的声明，在变量的访问中，会去检查在父类中是否存在这个变量。
					存在，则编译通过，否则报错
		运行看左：
		
	多态中的成员方法：
		编译看左：同成员变量
		运行看右：子类方法已重写，所以方法运行看右
	
	
63.抽象类和抽象方法的特点，有什么关系？
	在继承体系中：
		如果一个父类中的某个方法并不能满足子类的需求，子类需要对这个方法进行重写
			如果这个方法仅是为子类服务的，那么这个方法就可以定义为抽象方法
			抽象方法使用 abstract 关键字修饰
			抽象方法只有方法头，没有方法体
	当一个类中包含抽象方法时，这个类就必须定义为抽象类，定义抽象类 使用 abstract 修饰
		
	关系：抽象类为抽象方法提供生存环境

64.抽象类中的抽象方法和非抽象方法的区别？
	抽象方法没有方法体，需要使用 abstract 修饰符修饰
		抽象方法在子类中必须重写
		
	非抽象方法有方法体，子类中按需求决定是否进行重写

65.abstract不能和哪些关键字共同存在？
	abstract 不能和 static final native synchronized
	

66.final修饰的变量、方法、和类有什么特点？
	final 修饰变量：
		基本数据类型：常量，值将不能改变
		引用数据类型：常量，保存的引用地址不能改变
	
	final 修饰方法：
		标识最终方法，修饰的方法不可被重写
	
	final 修饰类：
		标识最终类，该类不能被继承

68.接口中的成员的特点？
	构造方法：接口中没有构造方法
	
	成员变量：默认使用 public static final 修饰 = 公开方法的静态常量
	
	成员方法：
		JDK7 及之前，接口中的方法只能是抽象方法
		JDK8 及之后，接口中可以定义默认方法（带有方法体，使用 default 关键字修饰）
		JDK8 及之后，接口中可以定义静态方法（带有方法体，使用 static 关键字修饰，static 代替default）
		JDK9 及之后，接口中可以定义私有方法（使用 private 修饰，为默认方法、静态方法服务）
		
	
69、类与类、类与接口、接口与接口的关系？
	类与类：
		继承关系：只可以单继承，可以多层继承
	
	类与接口：
		实现关系：可以单实现，可以多实现，可以继承加多实现
		
	接口与接口：
		继承关系：可以单继承，可以多继承
		
	
70.接口和抽象类的区别？
	接口多用来指定规则，抽象类多是为抽象方法提供了一个生存环境
	
	接口指定规则的时候，内部成员多是抽象方法
	
	抽象类内部可能包含较多的其他逻辑方法，并非专门用来指定规则的

71.接口的思想特点？
	制定规则，提高程序的扩展性
	内部多是抽象方法

72．什么是内部类，特点是什么？
	内部类：
		定义在类的内部的类
	特点：
		可以避免命名冲突
		可以使用外部类所有成员

73.成员内部类是什么？
	由于内部类是定义在类中的，定义在类中的都可以称为成员
		故内部类也可以叫做成员内部类

74.内部类的方法如何访问局部变量，内部类的成员变量，外部类的成员变量？
	内部类的方法访问局部变量
		直接访问变量名即可
	
	内部类的成员变量：可以通过 this 访问到
	
	外部类的成员变量：需要使用 外部类名.this.变量名 的方式访问
	
	
75.局部内部类访问的局部变量为什么要用final修饰？
	因为局部的变量也可以被局部内部类访问到，为了保证数据的安全性（局部代码也要使用），所以需要使用 final 修饰为常量

76．什么是匿名内部类？
	我们在使用 接口/抽象类 的时候，往往是需要 实现/继承 的方式创建 实现类/子类 
		然后在 实现类或子类中对抽象方法重写，然后构造实例，进行方法的调用
	
	匿名内部类本质上是一个 局部内部类，在局部内部中通过 new 关键字对接口或抽象类或父类 直接调用，在调用的时候，可以直接对前者中的抽象方法进行重写
		这样一来，我们就省去了 实现类/子类的 创建
		new 了之后，会返回一个 接口/抽象类/父类 的子类实例
		而 new 关键字所直接调用的那部分，就可以称为一个 “匿名内部类”

77.匿名对象何时使用？
	当某些地方需要某个 接口/抽象类/父类 的 实现类/子类 的实例的时候，我们可以省略掉创建 实现类/子类的过程，直接使用匿名构造类创建一个实例
		匿名构造类可以使用 接口/抽象类/父类 型的变量进行接收
	比如某个方法的形式参数是某个 接口/抽象类/父类 的类型

79.四种权限修饰符的比较？
	private：
		私有的，只可以在本类中使用
	默认的（没有修饰符）
		可以在同类、同包中访问; 子类、不同包都不能访问
		
	protected：
		受保护的，可以在同类、同包、子类（同包子类、不同包子类）访问到
		
	public：
		公共的，同类、同包、子类、无关类中都可以访问

80.package import class 有没有顺序？顺序是什么？
	有顺序
	package 第一位
	import 第二位
	class 第三位

81.代码块的分类：
	静态代码块
	构造代码块
	局部代码块
	
