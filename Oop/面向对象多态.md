# 面向对象多态

## 接口

当一个类中的**所有方法都是抽象方法**的时候，我们就可以将其定义为**接口**

接口也是一种引用数据类型，它比**抽象类**还要抽象

接口存在的两个重要意义：

1. **规则**的定义
2. 程序的**扩展性**

### 定义

接口用关键字 **interface** 来定义 `public interface 接口名 {}`

**特点**：

- 接口不能实例化
- 接口和类之间是实现关系，通过 **implements** 关键字表示

  > public class 类名 **implements** 接口 {}

- 接口的**子类（实现类）**
  - 要么重写接口中的**所有**抽象方法
  - 要么是**抽象类**

**注意**：一个类可以实现多个接口，接口之间使用 **,** 分割

- `public class InterImp implements Inter, InterA {}`

### 成员访问

- **成员变量**

  > 接口中的成员变量，系统默认使用 **public static final** 修饰
  >
  > 标识接口成员变量：公共的、静态的、最终的 = **公开访问的静态常量**

- **成员方法**

  > 只能是**抽象方法**（JDK7 及之前），方法默认添加 **public abstract**
  >
  > 标识方法是 公开的、抽象的 = **公开访问的抽象方法**

  **注意**：在一个实现类实现多个接口时，多个接口中存在相同的方法声明的话

  1. 如果重名的是**抽象方法**，无影响，正常编译
  2. 如果重名的是**普通方法**（带有方法体），实现类报错，需要实现类重写该方法

- **构造方法**

  > 接口中**没有构造方法**
  >
  > 如果在子类（实现类）中使用 **super()** 实际上调用的**父类**的构造方法

### JDK 高版本接口成员的特点

- **JDK8** 中，接口中允许定义**普通方法**（带有方法体的方法），使用 **default** 关键字修饰

  > **default** 将顶替 **abstract** ，去掉了 **abstract** 的修饰，方法也就不再是抽象方法，允许带有方法体

- **JDK8** 还允许在 接口中定义**静态方法**，添加 **static** 关键字

  > **static** 将会顶替 **default**

  > 接口中的**静态属性**：**接口.** | **实现类.** | **实例.** 都可以访问到；
  > 接口中的**静态方法**：只能 **接口.** 的方式访问

- **JDK9** 中，新增 接口内可以定义 **私有成员方法**

  > 方法添加 **private** 权限修饰符 且只能是 **静态方法**
  >
  > 接口中的私有方法是为接口的 默认方法、静态方法服务的；可以将 默认方法、静态方法中重复的逻辑提取到私有方法中，不被外界访问，不会影响到外界

接口中的方法**修饰符**整理：

- **abstract** = 接口抽象方法（默认添加）
- **default** = 接口默认方法（手动添加），带有方法体
- **static** = 接口静态方法（手动添加），带有方法体

都是公开访问的 **public**（默认添加）

### 类和接口的关系

**类和类**的关系

- 继承关系：只支持**单继承**，可以**多层继承**

**类和接口**的关系

- 实现关系：可以**多实现**
- 继承一个类的**同时可以实现多个接口**： `class Zi extend Fu implements InterA, InterB {}`

  > 如果父中的方法和接口中的方法重复，子类**优先使用父类**的方法

**接口和接口**的关系

- 继承关系，可以单继承，也可以多继承

  > 多继承的时候，如果多个父接口中有一样的方法，会造成**逻辑冲突**，子接口需要**重写**这个方法，作为**自己的**方法声明

### 小结

**接口定义**

当一个类中的所有方法都是 **抽象方法** 的时候，也就是说这个类的所有方法都要由子类来**重写**

定义抽象方法，实际上是保留了声明，然后子类按照这个声明对方法进行具体的实现

这样一来，这个全是抽象方法的类就变成了一个制定规则的一个类

这样的前提下，我们应该将这个类定义为接口

- 接口也是一种数据类型
- 接口使用 **interface** 进行定义
- 接口和类是同级别的
- 定义接口 **interface** 将 **class** 取缔

  > 也就是说 class 用来定义一个类，interface 用来定义一个接口

**接口实现**

一个接口要由另一个类来实现，所以我们将接口的子类称之为 **实现类**

实现类使用 **implements** 关键字类实现

**接口中的成员访问**：

- 接口没有构造方法
- 接口中的**成员变量**，系统默认使用 public static final 修饰 - **公开访问的静态常量**
- JDK7 及以前，接口中仅可以是 **抽象方法** -- 公共访问
- JDK8 及以后，接口中可以定义 **默认方法**（带有方法体）, 使用 default 关键字修饰 -- 公共访问
- JDK8 及以后，接口中可以定义 **静态方法**，使用 static 关键字修饰 -- 公共访问
- JDK9 及以后，接口中可以定义 **私有方法**，使用 private static 修饰 -- 为接口中的 默认方法、静态方法服务

**DemoCode：**

```java
public class InterfaceTest {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();

        // 接口不能实例化
        // new Animal(); // 报错

        // 实现类中的默认方法
        dog.showInfo();
        dog.kinetic(); // 多实现的方法

        System.out.println("-- --");
        cat.showInfo();

        System.out.println();

        // 接口的成员变量 = 公开的静态常量（不可改变）
        System.out.println("Dog.color = " + Dog.color); // Dog 实现类 访问接口静态属性 √
        System.out.println("dog.color = " + dog.color); // Dog 实例 访问接口静态属性 √

        System.out.println("Cat.color = " + Cat.color); // Cat 实现类 访问接口静态属性 √
        System.out.println("cat.color = " + cat.color); // Cat 实例 访问接口静态属性 √

        System.out.println();
        System.out.println("-- 接口静态方法 --");
        // dog.live(); // 访问不到
        // cat.live(); // 访问不到
        // Dog.live(); // 访问不到
        // Cat.live(); // 访问不到
        Animal.live(); // get


    }
}

interface Biology {
    void kinetic();
}

interface Animal {
    int age = 3;
    public static final String color = "紫色";

    /*
     * 接口中的所有方法都是抽象方法（定义规则）
     *
     * 接口中的方法，系统会自动添加 public abstract 两个修饰符
     *  用来标识 接口中的方法是 公共的、抽象的
     * 所以我们在定义方法的时候可以省略掉 public abstract
     *
     *  抽象方法的特性：只有方法头，没有方法体
     * */
    void drink();

    void eat();

    public abstract void voice();

    // jdk8 增加可以在接口中定义普通方法（带有方法体）= 默认方法
    public default void showInfo() {
        this.drink();
        this.eat();
        this.voice();
    }

    // jdk8 增加可以在接口中定义静态方法
    public static void live() {
        System.out.println("活的");
        run();
    }

    // jdk9 增加在接口中定义私有成员方法
    private static void run() {
        System.out.println("快跑");
    }
}


// 多实现
class Dog implements Animal, Biology {

    @Override
    public void drink() {
        System.out.println("狗喝水");
    }

    @Override
    public void eat() {
        System.out.println("狗吃肉");
    }

    @Override
    public void voice() {
        System.out.println("汪汪汪");
    }

    @Override
    public void kinetic() {
        System.out.println("活跃的");
    }

//    @Override
//    public void showInfo() {
//        this.drink();
//        this.eat();
//        this.voice();
//    }
}

// 单实现
class Cat implements Animal {

    @Override
    public void drink() {
        System.out.println("猫喝奶");
    }

    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    @Override
    public void voice() {
        System.out.println("喵喵喵");
    }

//    @Override
//    public void showInfo() {
//        this.drink();
//        this.eat();
//        this.voice();
//    }
}
```

## 多态

**同一个对象**，在**不同时刻**表现出来的**不同形态**

多态的前提和体现：

- 要有（继承/实现）关系
- 有方法重写
- 有父类引用指向子类实例

### 多态推导

---

```java
/**
 * 现有问题：
 *    如果某些具体的方法要使用 一个父类 的 不同子类 实例作为参数
 *    并且这些方法内部都是相同的
 *    那么，我们就需要写多个方法，通过重载的方式接收不同的子类型的参数
 *
 *    这样一来：既繁琐，又浪费资源
 *
 * 已知：
 *    多态的定义：同一个对象，在不同时刻表现出来的不同形态
 *    多态在字面量上表现为：父类引用接收子类实例地址
 *
 * 结合字面量解析定义：
 *    同一个对象：指字面量中的父类引用；
 *    在不同时刻：指赋值右边构建不同的子类；
 *    表现出来的不同形态：父类变量引用不同的 子类实例 地址。
 *
 * 白话：
 *    由于多态的特性，允许我们使用高级别（父类型）的变量，接收低级别（子类）的引用地址；
 *
 *    对 “高级别变量” 进行了声明，那么这个变量就代表了一个 “对象”，而这个对象究竟是怎样（不同的形态），这个要由具体的赋值（子类实例）来决定；
 *
 * 假设，有没有这样一种可能：
 *    由于 Java 是强类型语言，我每要使用一个类型的对象，我可能就要构建一个这个类型的 “对象”（类型变量引用实例地址）；
 *
 *    现在，有一个对象可以囊括我要使用的对象，我只需要构建这一个对象，然后再根据场景的变化，再将这个 “对象”（类型变量引用）变成具体的目标 “对象”；
 *
 *    答案：这个万能的对象就是 “父类”（高级别），具体的目标就是 该父类的子类（低级别）
 *
 *    那这个答案是否也就等于：父类 变量名 = new 子类实例
 *
 * 结论：
 *    多态就是一个对象，在不同时刻所体现出的不同形态
 *
 * 简化到字面量：父类 变量名 = new 子类实例
 *
 * */
```

---

**问题解决代码：**

```java
public class polymorphism {
    public static void main(String[] args) {
        Father superObj = new Child("大儿子", 18, "小龙女");
        Father superObj2 = new SecondChild("二儿子", 17, "如花");

        // 多个方法，内部逻辑一样，仅是通过重载，接收不同的参数
        // show(bigSon);
        // show(secondChild);

        // 多态修改：方法参数定义为父类，然后实参传入具体的实例
        superShow(superObj);
        superShow(superObj2);
    }

    public static void superShow(Father superObj) {
        /*
        * 在这个方法里面 superObj 其实一直就是一个对象,
        * 而在不同时刻表现出了不同的形态
        * */
        superObj.show();
    }

    public static void show(Child child) {
        child.show();
    }

    public static void show(SecondChild secondChild) {
        secondChild.show();
    }
}

class Father {
    String name;
    int age;
    String wife;

    public Father(String name, int age, String wife) {
        this.name = name;
        this.age = age;
        this.wife = wife;
    }

    public Father() {
    }

    public void show() {
        System.out.println("name：" + name + ", age：" + age + ", wife：" + wife);
    }
}

class Child extends Father {
    public Child(String name, int age, String wife) {
        super(name, age, wife);
    }

    public Child() {
    }

    @Override
    public void show() {
        System.out.println("妖魔鬼怪快走开");
    }
}

class SecondChild extends Father {
    public SecondChild(String name, int age, String wife) {
        super(name, age, wife);
    }

    public SecondChild() {
    }

    @Override
    public void show() {
        System.out.println("大威天龙");
    }
}
```

---

### 成员访问

- 构造方法：同继承一样，子类会通过 **super** 访问父类构造方法

- 成员变量：编译看左边（父类），运行看左边（父类）

- 成员方法：编译看左边（父类），运行看右边（子类）

> 编译的时候，JVM 只认识数据类型

为什么**成员变量和成员方法的访问**不一样？

- 因为成员方法有**重写**，成员变量没有**重写**

```java
/*
 * Java 的代码分为编译和运行两个阶段
 *   变量的声明是属于编译阶段的
 *   变量的赋值是属于运行阶段的
 *
 * 在构建多态时，使用父类型声明的变量空间
 *   在编译阶段，会检查变量所使用的成员（属性、方法）是否存在于父类中
 *       存在：编译通过
 *       不存在：编译报错
 *
 *   ===== 编译看左 =====
 *
 *   在运行阶段，将子类的实例赋值给了父类变量
 *       既然编译通过了，说明所使用的父类的属性都是在父类中存在的
 *       那么，子类也必定都继承了过来
 *       所以，多态实例 可以正常调用子类（继承自父类）的成员
 *
 *   此时，要明确的是变量里面是保存的子类的实例，当调用方法的时候，实际上调用的是子类中重写的方法
 *   而变量不可重写，故变量实际上为父类中的变量
 *
 *   ===== 变量运行看左    方法运行看右 =====
 *
 * */
```

### 多态的好处和弊端

- 好处：提高了程序的扩展性

  > 具体体现：定义方法的时候，使用父类型作为参数，该方法就可以接受这父类的任意子类对象

- 弊端：不能使用子类的特有功能

### 多态转型

- 向上转型

  > 从子到父

  > 父类引用指向子类实例：**Fu f = new Zi();**

- 向下转型

  > 从父到子

  > 父类引用转为子类对象：**Zi z = (Zi) f;**

如果要使用子类特有的功能，还是直接构造子类实例的好。

### 多态 Demo

```java
public class polymorphism {
    public static void main(String[] args) {
        Father bigSon = new Child("大儿子", 18, "小龙女", 90);
        Father secondSon = new SecondChild("二儿子", 17, "如花", 50);

        /*
        * 1. 多态推导
        * */
        // 多个方法，内部逻辑一样，仅是通过重载，接收不同的参数
        // show(bigSon);
        // show(secondChild);

        // 多态修改：方法参数定义为父类，然后实参传入具体的实例
        System.out.println("-- 成绩 --");
        superShow(bigSon);
        superShow(secondSon);

        /*
        * 2. 成员访问：
        * */
        // System.out.println("--- 成员访问 ---");
        // System.out.println("superObj.name = " + superObj.score);
        // superObj.study();

        // 多态的弊端：无法使用子类的特有功能
        // superObj.study(); // 编译报错
        // superObj2.game(); // 编译报错

        /*
         * 3. 多态转型：
         * 如果要使用子类特有的功能：
         *   1. 直接构建子类实例
         *   2. 将多态实例向下转型
         *       Zi z = (Zi) superObj;
         * */
        System.out.println();
        System.out.println("-- 爱好 --");
        hobby(bigSon);
        hobby(secondSon);
    }

    public static void superShow(Father superObj) {
        /*
         * 在这个方法里面 obj 其实一直就是一个对象,
         * 而在不同时刻表现出了不同的形态
         * */
        superObj.show();
    }

    public static void hobby(Father superObj) {
        /*
         * 通过 instanceof 判断 superObj 的类型，然后将 superObj 向下转型
         * */
        if (superObj instanceof Child) {
            Child c = (Child) superObj;
            c.study();
        } else if (superObj instanceof SecondChild) {
            SecondChild sc = (SecondChild) superObj;
            sc.game();
        }
    }

    public static void show(Child child) {
        child.show();
    }

    public static void show(SecondChild secondChild) {
        secondChild.show();
    }
}

class Father {
    String name;
    int age;
    String wife;

    public Father(String name, int age, String wife) {
        this.name = name;
        this.age = age;
        this.wife = wife;
    }

    public Father() {
    }

    public void show() {
        System.out.println("name：" + name + ", age：" + age + ", wife：" + wife);
    }
}

class Child extends Father {
    int score;

    public Child(String name, int age, String wife, int score) {
        super(name, age, wife);
        this.score = score;
    }

    public Child() {
    }

    @Override
    public void show() {
        System.out.println(this.name + " 考了 " + this.score);
    }

    public void study() {
        System.out.println(this.name + " 喜欢学习");
    }
}

class SecondChild extends Father {
    int score;

    public SecondChild(String name, int age, String wife, int score) {
        super(name, age, wife);
        this.score = score;
    }

    public SecondChild() {
    }

    @Override
    public void show() {
        System.out.println(this.name + " 考了 " + this.score);
    }

    public void game() {
        System.out.println(this.name + " 喜欢打游戏");
    }
}
```
