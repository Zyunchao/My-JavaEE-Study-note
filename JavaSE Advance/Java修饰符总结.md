# Java 修饰符总结

## 前言

Java 的**修饰符**根据修饰的对象不同，分为：

- **类**修饰符
- **方法**修饰符
- **变量**修饰符

其中**每种修饰符**又分为：

- **访问控制**修饰符（**权限**修饰符）
- **非访问控制**修饰符

访问控制存在的原因：

1. 让客户端程序员无法触及他们不应该触及的部分
2. 允许库设计者改变类内部的工作方法而不用担心影响到客户端程序员

## 1. 类修饰符

| 访问控制修饰符 |      类别      | 非访问控制符 |     类别     |
| :------------: | :------------: | :----------: | :----------: |
|   **public**   |  公共类修饰符  | **abstract** | 抽象类修饰符 |
|  **无修饰符**  | 缺省访问控制符 |  **final**   | 最终类修饰符 |

---

🔒 访问控制修饰符：

- **public**：公共类修饰符

  > Java 语言中，类的**控制符**只有 **public**，即公共的.
  >
  > 每个 **.Java** 程序文件中有且只有一个类是 **public**，它被称为**主类**，文件中的其他类**无**访问控制修饰符（即默认），具有**包访问性**.
  >
  > **注意**：一个类的内部可以被其他访问控制修饰符 **protected、default、private 修饰**，相当于**类的成员**。

- **类缺省访问控制符：**如果一个类没有访问控制符，说明它具有缺省的访问控制符特性

  > 此时，这个类只能被**同一个包中**的类访问或引用，这一访问特性又称为 **包访问性**

---

🌟 非访问控制符：

- **abstract**：抽象类修饰符

  > 用 **abstract** 修饰符修饰的类，被称为抽象类

- **final**：最终类修饰符

  > 当期望一个类不能被继承时，可用修饰符 **final** 修饰为**最终类**
  >
  > 被定义为 **final** 的类通常是一些有固定作用、用来完成某种标准功能的类

  > 所有被 **private** 修饰符限定为私有的方法，以及所有包含在 **final** 类 ( 最终类) 中的方法，都被认为是最终方法。

## 2. 方法修饰符

| 访问控制修饰符 |   类别   |   非访问控制符   |   类别   |
| :------------: | :------: | :--------------: | :------: |
|   **public**   | 公共访问 |   **abstract**   | 抽象方法 |
| **protected**  | 保护访问 |    **static**    | 静态方法 |
|  **default**   | 缺省默认 |    **final**     | 最终方法 |
|  **private**   | 私有访问 |    **native**    | 本地方法 |
|                |          | **synchronized** | 同步方法 |

---

🔒 访问控制修饰符：

---

🌟 非访问控制符：

- **abstract**：抽象方法控制符

  > 用修饰符 abstract 修饰的方法称为**抽象方法**。
  >
  > 抽象方法仅有方法头，没有方法体和操作实现。

- **static**：静态方法控制符

  > 用修饰符 **static** 修饰的方法称为**静态方法**；
  >
  > 静态方法是属于整个类的**类方法**。
  >
  > 而不使用 **static** 修饰、限定的方法是属于某个具体类对象的方法（**实例方法**）。

  > **注意**：由于 **static** 方法是属于**整个类**的，所以它不能操纵和处理属于某个对象的**成员变量**，而**只能处理**属于整个类的成员变量，即 **static** 方法只能处理 **static** 的域。

- **final**：最终方法控制符

  > 用修饰符 **final** 修饰的方法称为**最终方法**。
  >
  > 最终方法是功能和内部语句不能更改的方法，即最终方法不能重写覆盖。

  > **final** 固定了方法所具有的功能和操作，防止当前类的子类对父类**关键方法**的**错误定义**，保证了程序的安全性和正确性。

- **native**：本地方法控制符

  > 用修饰符 native 修饰的方法称为**本地方法**。
  >
  > 为了提高程序的运行速度，需要用其它的高级语言书写程序的方法体，那么该方法可定义为本地方法用修饰符 native 来修饰。

- **synchronized**：同步方法控制符

  > 该修饰符主要用于多线程程序中的协调和同步。

## 3. 变量修饰符

| 访问控制修饰符 |   类别   | 非访问控制符  |       类别       |
| :------------: | :------: | :-----------: | :--------------: |
|   **public**   | 公共访问 |  **static**   |      静态域      |
| **protected**  | 保护访问 |   **final**   |      最终域      |
|  **default**   | 缺省默认 | **volatile**  | 易失 ( 共享 ) 域 |
|  **private**   | 私有访问 | **transient** |     暂时性域     |

---

🔒 访问控制修饰符：

- **public**：公共访问控制符

  > 用 **public** 修饰的域称为公共域。
  >
  > 由于 **public** 修饰符会降低运行的安全性和数据的封装性，所以一般应减少 public 域的使用。

- **private**：私有访问控制符

  > 用 **private** 修饰的成员变量 ( 域 ) 只能被该类自身所访问，而不能被任何其它类 ( 包括子类 ) 所引用。

- **protected**：保护访问控制符

  > 用 protected 修饰的成员变量可以被三种类所引用：

  > 1. 该类自身
  > 2. 同一个包中的其他类
  > 3. 其他包中的子类

  > 使用修饰符 **protected** 的主要作用是允许其它包中的子类来访问父类的特定属性。

- **缺省默认修饰符**：没有访问控制修饰符或用**修饰符 default** 修饰的成员变量可以被该类，本身或同一包中的其他类访问。

---

🌟 非访问控制符：

- **static**：静态域修饰符

  > 用 **static** 修饰的成员变量仅属于类的变量，而不属于任何一个具体的对象;
  >
  > 静态成员变量的值是保存在类的内存区域的公共存储单元，而不是保存在某一个对象的内存区间。
  >
  > 该类的任一对象访问它时取到的都是**相同的数据**；该类的任一对象修改它时 , 也都是对**同一个内存单元**进行操作。

- **final**：最终域修饰符

  > 最终域修饰符 final 是用来定义常量的。
  >
  > 一个类的域 ( 成员变量 ) 如果被修饰符 final 说明，则它的取值在程序的整个执行过程中都是不变的。

- **volatile**：易失 ( 共享 ) 域修饰符

  > 易失 ( 共享 ) 域修饰符 **volatile** 是用来说明这个成员变量可能被几个线程所控制和修改。
  >
  > 也就是说在程序运行过程中，这个成员变量有可能被其它的程序影响或改变它的取值。

  > 通常 **volatile** 用来修饰接受外部输入的域。

- **transient**：暂时性域修饰符
  
  > 暂时性域修饰符 **transient** 用来定义一个暂时性变量。
  >
  > **其特点是**：用修饰符 **transient** 限定的暂时性变量，将指定 Java 虚拟机认定该暂时性变量不属于永久状态，以实现不同对象的存档功能。
  >
  > 否则，类中所有变量都是对象的永久状态的一部分，存储对象时必须同时保存这些变量。

## 权限修饰符（访问控制符）总结

| 访问级别 | 权限修饰符 | 同类 | 同包 | 子类 | 不同包 |
| :------: | :--------: | :--: | :--: | :--: | :----: |
|   公开   |   public   |  ✅   |  ✅   |  ✅   |   ✅    |
|  受保护  | protected  |  ✅   |  ✅   |  ✅   |   ❌    |
|   默认   | 没有修饰符 |  ✅   |  ✅   |  ❌   |   ❌    |
|   私有   |  private   |  ✅   |  ❌   |  ❌   |   ❌    |

