public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int num = 10;
        // int index = getIndex(arr, num);

        int index = getIndex2(arr, num, 0, arr.length - 1);
        System.out.println("index = " + index);
    }

    // 循环解决
    private static int getIndex(int[] arr, int num) {
        int min = 0, max = arr.length;
        while (min != max) {
            int mid = (min + max) / 2;
            if (arr[mid] == num) {
                return mid;
            }

            if (arr[mid] > num) {
                max = mid - 1;
            } else if (arr[mid] < num) {
                min = mid + 1;
            }
        }
        return -1;
    }

    // 递归解决
    public static int getIndex2(int[] arr, int num, int min, int max) {
        /*
         * 二分查找：
         * 在二分查找中，以元素的索引位置为基准
         * 二分查找的是通过查找索引来完成数据的查找的
         * 要查找索引，就要有一个索引的取值范围
         *   取值范围：0 ~ arr.length - 1
         *   假设有十个数，索引的取值范围就是 0 ~ 9
         *
         *   在索引的取值范围内，获取到索引的中间值
         *       获取索引中间值，也就是在 10 个数中，中间位置的数
         *   获取中间位数的索引的目的是取到位于中间位置的数，
         *       由于二分查找的前提是数组中的元素必须是有序的
         *   所以，这个中间索引位置的数的
         *       左边 = 小于中间值数
         *       右边 = 大于中间值数
         *
         *   如果要查找的数比我们获取的中间值大，说明在右边
         *       反之，在左边
         *
         *  如此重复查找，知道取的中间值 为目标数据，则返回 mid 值
         * */


        /*
         * 二分查找的前提：数组是有序的（局限性）
         *
         * 1. 以索引的范围为基准进行查找
         *       最小索引 --> 最大索引
         *
         * 2. 找出索引范围的中间值（索引的中间值 == 数组中元素的中间值）
         *       (最小索引 + 最大索引) / 2 = 中间值
         *
         * 3. 目标数据与中间值比对
         *       1. 目标数据大于中间值，说明目标数据的位置在中间位置的右边
         *       2. 目标数据小于中间值，说明目标数据的位置在中间位置的左边
         *
         * 4. 通过与中间值的比对，缩小了索引的范围（中间值的左边和右边）
         *       1. 左边：缩小索引范围的方式为 最小索引不变，最大索引改变为中间值 -1（这样一来，就去掉了右边部分）
         *       2. 右边：缩小索引范围的方式为 最大索引不变，最小索引改变为中间值 +1（去掉了不符合的左边部分）
         *
         * 5. 缩小索引范围后，重复 1、2、3、4
         *
         * 关于循环的结束条件分析：
         *   首先明确循环的作用：多次查找中间值，然后与中间值比对，需要有尽头
         *
         *   当我们缩小索引的范围时，无非两种情况：
         *       1. 目标数据在中间值的左边：减小最大的值的量
         *       2. 目标数据在中间值的右边：增大最小值的量
         *   无论哪种情况，索引范围一直缩小，最小无非最大最小值重合
         *       那么，这时，如果还没有找到数据，就会
         *           1. 目标数据还比取值范围中的数值大，那 min 就要执行增值
         *           2. 目标数据还比取值范围中的数值小，那 max 就要执行减值
         *
         *       这两种情况都会导致 max 比 min 要小
         *       这时候，在去获取 mid 值，出现了差错
         *
         *       那么，我们也就要保证 min 一定要小于或等于（正常取值范围/最小取值范围） max 才能进行查找
         *       所以循环的条件为 min <= max
         *       结束循环的条件为：min > max
         *
         *
         *
         *
         *
         * */
        if (min > max) {
            return -1;
        }

        int mid = (min + max) / 2;

        if (arr[mid] == num) {
            return mid;
        } else if (arr[mid] > num) {
            // 中间值大于目标值，说明目标值在中间的左边
            // 应该 max 的取值范围减小
            max = mid - 1;
        } else if (arr[mid] < num) {
            // 中间值小于目标值，说明目标值在中间值的右边
            // 应该使 min 的取值范围增大
            min = mid + 1;
        }
        return getIndex2(arr, num, min, max);
    }
}
