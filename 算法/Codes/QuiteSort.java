package arithmetic;

import java.util.Arrays;

public class QuiteSort {
    public static void main(String[] args) {
        int[] arr = {6, 8, 9, 7, 10, 2, 4, 5, 3, 1};

        quiteSort(arr, 0, arr.length - 1);
        System.out.println("Arrays.toString(arr) = " + Arrays.toString(arr));
    }

    /*
     *
     * 需求问题：
     *   一个乱序的的 int 数组，使用升序排序
     *
     * */
    public static void quiteSort(int[] arr, int min, int max) {
        /*
         *
         * 快排的基本思想：
         *   1. 依据基准数对其他数据分位
         *   2. 基准数归位
         *
         * 快排也使用了 索引范围值的思想
         *
         * 1. 首先确定一个基准数，多以数组中的第一个元素为基准数
         *
         * 2. 在数组的给定的索引取值范围内，确定两个指针
         *       1. 高位指针(给定的 max 值)：从右往左找，寻找比基准数小的值
         *       2. 低位指针(给定的 min 值)：从左往右找，寻找比基准数大的值
         *
         * 3. 假设当 ”高位指针“ 找到了 ”高位区“ 比基准数小的数，停下来
         *       停下来的目的是为了暂时保留 “高位区” 比基准数小的那个数的索引，为后面的 “换位” 做准备
         *
         * 4. 然后，”低位指针“ 寻找 ”低位区“ 比基准数大的数，找到后
         *       使用找到的 ”低位区“ 中的 ”高位数“ 的索引与 “高位指针” 在 ”高位区“ 找到的 ”低位数“ 的索引 ”换位“
         *
         * 5. 当完成了一次 “换位” 后，进入第二次寻找的流程，重复 1. 2. 3. 4. 步骤
         *
         * 6. 每次都是 “高位指针” 先行，当找到最后一个 “高位区” 中的 “低位数” 后
         *       如何知道是不是最后一个 “低位数”，“高位指针” 先行，当 “低位指针” 与 “高位指针” 重合时，说明 “低位区” 已经查找完了，那对应的 “高位区” 也查找完了
         *       故：重合的这个位置也就是最后一个 “低位数”
         *
         *       故：
         *       循环执行的条件为：min != max
         *       循环结束的条件为：min == max
         *
         * 7. 试想，如果 “高位指针” 一直往左查找，“低位指针” 一直向右查找，二者交汇之后又错过，那将是毫无意义的
         *       所以，要满足查找的条件：
         *           “低位指针“ 不能大于 ”高位指针“
         *
         * 8. 当循环停止后，“高位指针” 与 “低位指针” 重合，高位指针获取的最后一个低位数
         *       此时将 基准数 和这最后一个 低位数互换，也就是所谓的 基准数归位
         *       这时，也就完成了 “以基准数为基准的高低位区划分”
         *
         * 9. 重复如上过程，完成所有的基准数归位
         * */

        /*
         * 保留 “低位指针” 与 “高位指针” 的初始值
         * 获取基准数
         * */
        if (min > max) return;

        int min0 = min, max0 = max, baseItem = arr[min0];

        while (min != max) {
            /*
             * ”高位指针“ 查找 ”高位区“ 中的 ”低位数“
             * 循环查找条件：
             *      如果当前位的数值大于基准数，那说明当前数应该就待在 “高位区”
             *      进入下一个数据的比对：max - 1
             *
             * “高位指针” 在移动的过程中，应该保证与已有 “低位指针” 不重叠
             * */
            while (arr[max] >= baseItem && min < max) {
                max--;
            }

            /*
             * “低位指针” 查找 “低位区” 中的 “高位数”
             * 循环查找条件：
             *       如果当前位的数值小于基准数，说明当前数是正确的
             *       进入下一个数据比对：min + 1
             *
             * */
            while (arr[min] <= baseItem && min < max) {
                min++;
            }

            /*
             * 当以上两个循环不满足条件时：
             *   “高位指针” 找到了 “高位区” 中的 “低位数”
             *   “低位指针” 找到了 “低位区” 中的 “高位数”
             *
             * 循环停止，min 和 max 被保留了对应的位置
             * 此时，使 “低位指针” 与 “高位指针” 指向的数据 互换位置
             * */

            int temp = arr[min];
            arr[min] = arr[max];
            arr[max] = temp;

            /*
             *
             * 当完成一次 “高低位数” 的互换后，不应该停止查找
             * 应该继续查找剩下位置不正确的 “高低位数”
             * 外层循环，控制再来一次
             * */
        }
        /*
         * 基准数归位
         * 当 “高位指针” 与 “低位指针” 重合后，说明 “高位指针” 找到了最后一个 “低位数”
         * 此时，将基准数与“最后一个” 低位数互换位置
         * */
        int temp = arr[min0];
        arr[min0] = arr[max];
        arr[max] = temp;

        /*
         * 当完成了第一次基准数归位后，还保留着正确的基准数的位置
         * 此时，整个数组分为两个区域：
         *   基准数左边：全都是小于基准数的数（低位区）
         *   基准数右边：全都是大于基准数的数（高位区）
         *
         * 我们按照同样的逻辑，对低位区、高位区同时进行基准数归位及划分位区
         * 使用递归来完成，那么对应的参数
         *
         *   高位区：
         *       quiteSort(数组, 现有基准位 + 1, 原有高位指针位置);
         *
         *   低位区：
         *       quiteSort(数组, 原有低位区起始, 现有基准位 - 1);
         * */

        quiteSort(arr, max + 1, max0);
        quiteSort(arr, min0, max - 1);
    }
}
